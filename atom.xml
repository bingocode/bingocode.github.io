<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://bingocode.github.io/</id>
    <title>BingoCode</title>
    <updated>2019-07-29T15:07:44.898Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://bingocode.github.io/"/>
    <link rel="self" href="https://bingocode.github.io//atom.xml"/>
    <subtitle>先天领周天，盖周天之变，化吾为王</subtitle>
    <logo>https://bingocode.github.io//images/avatar.png</logo>
    <icon>https://bingocode.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, BingoCode</rights>
    <entry>
        <title type="html"><![CDATA[Flutter基础]]></title>
        <id>https://bingocode.github.io//post/flutter-ji-chu</id>
        <link href="https://bingocode.github.io//post/flutter-ji-chu">
        </link>
        <updated>2019-07-29T07:22:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="flutter概述">Flutter概述</h1>
<p>2018 年 12 月初，Google 正式发布了开源跨平台 UI 框架 Flutter 1.0 Release 版本。Flutter是一个使用Dart语言开发的跨平台移动UI框架，渲染引擎依赖Skia图形库实现，在Flutter中的控件树编译为高性能的本地ARM代码直接绘制。Dart是Flutter的主要开发语言 ，支持JIT编译（开发阶段可热重载）和AOT编译（Release运行阶段性能好）</p>
<h1 id="flutter工程类型">Flutter工程类型</h1>
<h2 id="flutter-application">Flutter Application</h2>
<p>标准的 Flutter App 工程，包含标准的 Dart 层与 Native 平台层。</p>
<h2 id="flutter-module">Flutter Module</h2>
<p>Flutter 组件工程，仅包含 Dart 层实现，Native 平台层子工程为通过 Flutter 自动生成的隐藏工程（.ios/.android）。</p>
<h2 id="flutter-plugin">Flutter Plugin</h2>
<p>Flutter 平台插件工程，包含 Dart 层与 Native 平台层的实现。</p>
<h2 id="flutter-package">Flutter Package</h2>
<p>Flutter 纯 Dart 插件工程，仅包含 Dart 层的实现，往往定义一些公共 Widget。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dart语法]]></title>
        <id>https://bingocode.github.io//post/dart-yu-fa</id>
        <link href="https://bingocode.github.io//post/dart-yu-fa">
        </link>
        <updated>2019-07-28T14:20:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="语言概述">语言概述</h1>
<ul>
<li>Dart 语言在2011年10月由 Google 发布的网络编程语言，并在2012年10月发布第一个里程碑版本M1，2015年5月Google公开了基于Dart语言的移动应用程序开发框架Sky，后更名为Flutter</li>
<li>Flutter是一个使用Dart语言开发的跨平台移动UI框架，渲染引擎依赖Skia图形库实现，在Flutter中的控件树编译为高性能的本地ARM代码直接绘制。Dart是Flutter的主要开发语言 ，支持JIT编译（开发阶段可热重载）和AOT编译（Release运行阶段性能好）</li>
<li>Dart可利用隔离区（Isolate)实现多线程，且不共享内存，实现无锁快速分配</li>
<li>Dart采用分代垃圾回收机制，且在创建对象分配内存时，是在现有堆上移动指针，保证内存增长是线性的，有利于UI框架中大量Widgets对象的创建和销毁优化</li>
<li>Dart是面向对象的、类定义的、单继承的语言，一切都是对象（包括基本类型，函数，null），所有对象都继承自Object</li>
<li>Dart是强类型语言，但也自带类型推断</li>
<li>Dart中没有public，private，protected，默认都是public的，可以通过_开头指定是库私有的</li>
</ul>
<h1 id="变量">变量</h1>
<p>Dart为强类型语言，变量可显式声明，也可自动推断，但推断出来后，该变量的类型将不再改变，若要让变量不被限制于一种类型，可将变量声明为dynamic。</p>
<h2 id="类型">类型</h2>
<ul>
<li>数字num
int: 平台的不同,范围也不同。整数值不大于64位。在Dart VM上，值可以从-2^63到2^63 - 1
double: 64位(双精度)浮点数
数字和字符串转换：</li>
</ul>
<pre><code>int.parse('1') 
3.14159.toStringAsFixed(2);
</code></pre>
<ul>
<li>字符串String
String是UTF-16编码单元的序列，可以使用${expression}将表达式的值放入字符串中。如果表达式是一个标识符，可以不用{},</li>
</ul>
<pre><code>String str = &quot;world&quot;;
print(&quot;hello$str&quot;);
</code></pre>
<p>可以用三重引号创建多行字符串，用r前缀创建一个原始字符串（不会因为有\n换行）</p>
<pre><code>var s = r'In a raw string, not even \n gets special treatment.';
print(s); //虽然有换行符，但输出不会换行
</code></pre>
<ul>
<li>布尔型(bool):true, false</li>
<li>列表List
数组即为列表对象</li>
</ul>
<pre><code>var list = [1,2,3];  //推断为List&lt;int&gt; 类型，若添加非int对象，则会报错
</code></pre>
<ul>
<li>映射Map
可以通过map字面量直接创建，也可以通过Map()构造方法创建, 类型会自动推断</li>
</ul>
<pre><code>var g = { 1: 'a', 2: 'b', 3: 'c'}
var g1 = Map();
g1[1] = 'a1'
final constantMap = const {2: 'b', 3: 'c'};
</code></pre>
<ul>
<li>字符Runes:
字符是字符串的UTF-32编码</li>
<li>符号Symbols:</li>
</ul>
<pre><code>print(#bar) 
// 输出 Symbol(&quot;bar&quot;)
</code></pre>
<h2 id="变量声明">变量声明</h2>
<p>Dart没有public protected private等关键字，如果某个变量以下划线开头，代表这个变量在库中是私有的</p>
<pre><code>String me = &quot;Bob&quot;;  // 显式name变量声明为String
var you = &quot;Bob&quot;;   // 自动推断name变量为String
dynamec he = “Bob”;   // 声明变量为任意类型，类似于java中Object
he = 18;   
int u;  // 未初始化的变量初始值为null，变量存放的是对象，对象都继承自Object类
final a;  // 最终变量，只能设置一次，顶级或类变量在第一次使用时被初始化
const b;  // 编译时常量，注意实例变量可以是final，但不能是const。
var f = const[];
f = [1,3];   // 可以更改一个非final的且非const变量的值，即使它曾经有一个const值
</code></pre>
<h1 id="运算符">运算符</h1>
<h2 id="相等">相等（==）</h2>
<p>若两者都为空则返回true，若只有一空返回false；
需要知道两个对象是否完全相同的情况下，可以使用identical()函数</p>
<h2 id="类型判断is">类型判断（is）</h2>
<p>若obj 实现了T，则 obj is T 为真</p>
<h2 id="类型转换as">类型转换（as）</h2>
<p>as操作符将对象转换为特定类型</p>
<h2 id="非空赋值">非空赋值（??=)</h2>
<pre><code>b ??= value;  //仅仅在b为空的情况下b被赋值value否则b的值不变
</code></pre>
<h2 id="条件表达">条件表达（??）</h2>
<pre><code>expr1 ?? expr2 ； //如果expr1是非空的，则返回其值，否则，计算并返回expr2的值
</code></pre>
<h2 id="级联">级联（..）</h2>
<p>在同一个对象上创建一个操作序列。可以访问同一对象上的字段，调用函数，省去创建临时变量的步骤。
不能在一个返回void结果上继续构建级联操作</p>
<pre><code>querySelector('#confirm') // 获取一个对象
  ..text = 'Confirm' // 使用它的成员
  ..classes.add('important')
  ..onClick.listen((e) =&gt; window.alert('Confirmed!'));
</code></pre>
<p>等同于·</p>
<pre><code>var button = querySelector('#confirm');
button.text = 'Confirm';
button.classes.add('important');
button.onClick.listen((e) =&gt; window.alert('Confirmed!'));
</code></pre>
<h2 id="条件成员访问">条件成员访问（?.）</h2>
<p>如果左边的操作对象为null则返回null，否则返回右边的成员</p>
<h1 id="函数">函数</h1>
<p>函数也是对象，可以赋给函数，也可以赋给变量，甚至可以是函数的返回值。函数可以省略返回类型声明(可以根据return自动推断)，所有函数都默认返回null（没有return语句）</p>
<h2 id="函数简写">函数简写</h2>
<pre><code>isBelowZero(int n) =&gt; n &lt; 0; //只包含一个表达式的函数简写
</code></pre>
<h2 id="命名参数">命名参数</h2>
<p>在定义函数时，使用{param1, param2，…}来指定命名参数</p>
<pre><code>void enableFlags({bool bold, bool hidden}) {...}
enableFlags(bold: true, hidden: false);
</code></pre>
<h2 id="可选参数">可选参数</h2>
<p>在普通的位置参数里，可以通过[]包装为一组可选参数，在命名参数里，可以通过@required标识必传参数，其他都是可选的。</p>
<pre><code>say(String from, String msg, [String device])
Scrollbar({Key key, @required Widget child})
</code></pre>
<h2 id="默认参数">默认参数</h2>
<p>用 = 来定义参数的默认值。默认值必须是编译时常量。如果没有提供默认值，则默认值为null</p>
<pre><code>void enableFlags({bool bold = false, bool hidden = false})
</code></pre>
<h2 id="main函数">main()函数</h2>
<p>应用程序的入口点。返回void，并有一个可选的列表参数作为参数</p>
<pre><code>void main(List&lt;String&gt; arguments) {
  print(arguments);
  assert(arguments.length == 2);
  assert(int.parse(arguments[0]) == 1);
  assert(arguments[1] == 'test');
}
</code></pre>
<h2 id="匿名函数">匿名函数</h2>
<pre><code> ([[Type] param1[, …]]) {
    codeBlock;
 };
</code></pre>
<h2 id="函数类型">函数类型</h2>
<p>typedef为函数提供一个类型别名</p>
<pre><code>typedef Compare&lt;T&gt; = int Function(T a, T b);
int sort(int a, int b) =&gt; a - b;
void main() {
assert(sort is Compare&lt;int&gt;); // True!
}
</code></pre>
<h1 id="流程控制">流程控制</h1>
<h2 id="循环迭代">循环迭代</h2>
<pre><code>//若对象是可迭代的
candidates.forEach((candidate) =&gt; candidate.interview());
//List和Set等支持for in迭代
for (var x in collection) { }
</code></pre>
<h2 id="过滤器where">过滤器where</h2>
<p>即使where筛选后为空也没问题，只是不会执行后面的forEach</p>
<pre><code>candidates
 .where((c) =&gt; c.yearsExperience &gt;= 5)
 .forEach((c) =&gt; c.interview());
</code></pre>
<h2 id="switch">switch</h2>
<p>每个非空的case子句以一个break语句结束,否则会报错,default 可以没有。</p>
<h1 id="类和库">类和库</h1>
<p>Dart值支持单继承，所有类都是Object的子类，支持泛型。库的导入用import</p>
<pre><code>import 'package:lib1/lib1.dart';
import 'package:lib2/lib2.dart' as lib2;  //导入有冲突时指定前缀
import 'package:lib1/lib1.dart' show foo; //只导入foo
import 'package:lib2/lib2.dart' hide foo; //除了foo其他导入
import 'package:greetings/hello.dart' deferred as hello; //延时加载
Future greet() async {
  await hello.loadLibrary(); //需要时加载，可以在库上多次调用loadLibrary()。该库只加载一次
  hello.printGreeting();
}
</code></pre>
<p>类实现call方法，则可以通过类对象直接调用函数</p>
<pre><code>class WannabeFunction {
  call(String a, String b, String c) =&gt; '$a $b $c!';
}
var wf = new WannabeFunction();
var out = wf(&quot;Hi&quot;, &quot;there,&quot;, &quot;gang&quot;);
print('$out');
</code></pre>
<h1 id="异步">异步</h1>
<h2 id="async和await">async和await</h2>
<p>通过将函数体用async修饰符标记，将使其返回一个Future，声明异步函数。如果异步函数没有返回一个有用的值，那么将其返回Future<void>类型。await必须是在一个使用async标注的异步函数使用,await表达式会让程序执行挂起，直到返回的对象可用。在await表达式中，表达式的值通常是一个Future对象。如果不是，那么这个值将被自动包装成Future</p>
<pre><code>String lookUpVersionSync() =&gt; '1.0.0';  //同步函数
Future&lt;String&gt; lookUpVersionAsync() async =&gt; '1.0.0';; //异步函数
Future checkVersion() async {
  var version = await lookUpVersionAsync();
}
</code></pre>
<h2 id="隔离器isolate">隔离器（Isolate）</h2>
<p>不同于线程，所有Dart代码都运行在隔离器内部，而不是线程。每个隔离都有它自己的内存堆，确保任何其他隔离器都不能访问隔离状态</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android蓝牙开发知识沉淀]]></title>
        <id>https://bingocode.github.io//post/android-lan-ya-kai-fa-zhi-shi-chen-dian</id>
        <link href="https://bingocode.github.io//post/android-lan-ya-kai-fa-zhi-shi-chen-dian">
        </link>
        <updated>2019-07-10T08:05:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="蓝牙通用知识概述">蓝牙通用知识概述</h2>
<h3 id="发展历史">发展历史</h3>
<p>蓝牙技术是一种近距离无线通信技术，始于爱立信公司1994年的技术方案，在1998年，索尼，英特尔，诺基亚等创立特别兴趣小组（蓝牙技术联盟的前身），负责蓝牙规范的制定和推广
<img src="https://bingocode.github.io//post-images/1563423177160.png" alt=""></p>
<h3 id="协议栈">协议栈</h3>
<p><img src="https://bingocode.github.io//post-images/1563423650923.png" alt=""></p>
<ul>
<li>控制器：底层实现，直接和硬件相关，由芯片厂商实现</li>
<li>主机：硬件的抽象。其中通用访问控制配置文件（GAP）。定义了 BLE 整个通信过程中的流程，负责处理设备访问模式和程序，包括设备发现、建立连接、终止连接等等。GAP 层总是作为下面四种角色之一：（1）广播者：不可连接的广播设备。（2）观察者：扫描设备，但不发起建立连接 （3）外部设备：可连接的广播设备，可以在单个链路层连接中作为从机。（4）集中器：扫描广播设备并发起连接，可以在单链路层连接中作为主机</li>
<li>应用层：使用主机层提供的API开发应用</li>
</ul>
<h3 id="ble应用">BLE应用</h3>
<ul>
<li>基于非连接的：不与周边设备发生连接，主要靠扫描到的广播来获取信息。发送广播的一方为广播者（传感器broadcaster），监听广播的一方为观察者（observer），这种方式可以用来实现室内定位。每个广播数据包由31byte组成，</li>
<li>基于连接的：两个设备建立GATT连接，形成外围设备（Peripheral）和中心设备（Centeral），一个中心设备可以连接多个外设，但是一个外设只能连接一个中心（外设连接成功后会停止对外广播，因此别人就发现不了它了），一个中心设备的连接外设的数量也是有限的。</li>
</ul>
<h2 id="蓝牙分类">蓝牙分类</h2>
<p>Android平台提供了Bluetooth API来访问蓝牙功能，可以进行设置蓝牙，查找局部区域内的配对设备，连接设备以及传输数据。</p>
<ul>
<li>传统蓝牙：适用于电池使用强度较大的操作，如设备之间的流传输和通信</li>
<li>低功耗蓝牙：Android 4.3 （API 18 ）引入了低功耗蓝牙，有些BLE设备一个纽扣电池可以用一两年，因为传输的数据量很少。适用于很多物联网应用场景</li>
</ul>
<ul>
<li>属性协议（ATT Attribute Protocol）：ATT 是整个BLE通信的基础，负责数据封装，使用尽可能少的字节，向外暴露属性的为服务端，获取属性的为客户端。每个属性由通用唯一标识符（UUID）来唯一标识。ATT 传输的属性被格式化为<strong>特征</strong> 和<strong>服务</strong></li>
<li>通用属性配置文件（GATT Generic Attribute Profile）：是一种传输数据规范，是基于 ATT 做的进一步的逻辑封装，定义数据的交互方式和含义。也被称为 GATT/ATT 。用于在 BLE 链路上发送和接受被称为属性的短数据的通用规范。目前所有低功耗应用配置文件基本都是基于 GATT。GATT 定义了三个非常重要的概念：服务（Service）、特征（Characteristic）、描述（Descripter）。他们的关系如下图
<img src="https://bingocode.github.io//post-images/1563429896314.png" alt="">
一个 Service 可以包含若干个 Characteristic，一个 Characteristic 可以包含属性（properties）和值（value），还可以包含多个 descripter 。Characteristic 实际上具有读、写、通知等权限。我们在对一个 BLE 设备发起连接成功以后，对他进行读写操作，其实就是对 Characteristic 的操作。图中的 Profile 是一组服务的集合，这些服务组个起来就形成了一个特定的使用场景了，里面的服务是嵌入式工作人员可以添加的。BLE 蓝牙使用 UUID 来区分 Service、Characteristic 、Descripter。</li>
<li>特征：征包含单个值和描述特征值的 0 ~ n 个描述符，BLE 设备进行通信的时候主要的操作内容</li>
<li>服务：服务中包含一系列的特征值。例如，我们可以使用名为 “心率监测器”的服务，其中包括&quot;心率测量&quot;等特征</li>
</ul>
<h2 id="蓝牙相关类">蓝牙相关类</h2>
<p>蓝牙相关的API在android.bluetooth包中</p>
<h3 id="bluetoothadapter">BluetoothAdapter</h3>
<p>本地蓝牙适配器。是所有蓝牙交互的入口，整个系统只有一个蓝牙适配器。</p>
<h3 id="bluetoothdevice">BluetoothDevice</h3>
<p>远程的蓝牙设备。利用它可以通过 <strong>BluetoothSocket</strong> 请求与某个远程设备建立连接和查询设备的信息如名称，地址，绑定状态等</p>
<h3 id="bluetoothsocket">BluetoothSocket</h3>
<p>蓝牙套接字接口。类似于TCP Socket，允许应用通过 <strong>InputStream</strong> 和 <strong>OutputStream</strong> 与其他蓝牙设备进行数据交换</p>
<h3 id="bluetoothserversocket">BluetoothServerSocket</h3>
<p>用于监听传入请求的开发服务器套接字。类似于 TCP ServerSocket，要连接两台 Android 设备，其中一台设备必须使用此类开发的一个服务器套接字。当一台远程蓝牙设备向此设备发出连接请求时，<strong>BluetoothServerSocket</strong> 将会在接受连接后返回已连接的 <strong>BluethoothSocket</strong>。</p>
<h3 id="bluetoothclass">BluetoothClass</h3>
<p>蓝牙类。描述蓝牙设备的一般特性和功能。这是一组只读属性，用于定义设备的主要和次要设备类及其服务。不过它不能可靠地描述设备支持的所有蓝牙配置文件和服务，而是适合作为设备类型提示</p>
<h3 id="bluetoothprofile">BluetoothProfile</h3>
<p>蓝牙配置文件接口。适用于设备间蓝牙通信的无线接口规范。免提配置文件便是一个示例，对于连接到无线耳机的手机，两台设备都必须支持免提配置文件。我们也可以通过实现 <strong>BluetoothProfile</strong> 接口来写入自己的类来支持特定的蓝牙配置文件。Android API 提供了耳机（<strong>BluetoothHeadset</strong>），高质量音频（<strong>BlutoothA2dp</strong>），健康设备（<strong>BluetoothHealth</strong>）这几种蓝牙配置文件的实现。</p>
<h3 id="bluetoothgatt">BluetoothGatt</h3>
<p>低功耗蓝牙通信的配置文件代理。实现了<strong>BluetoothProfile</strong></p>
<h2 id="蓝牙开发权限和配置">蓝牙开发权限和配置</h2>
<h3 id="权限">权限</h3>
<p>请求连接、接受连接、和传输数据</p>
<pre><code>&lt;uses-permission android:name = &quot;android.permission.BLUETOOTH&quot;/&gt;
</code></pre>
<p>发现或者操作蓝牙设置</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&gt;
</code></pre>
<p>如果是采用BLE蓝牙，通常还需要声明位置权限</p>
<pre><code>  &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;
  &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;
</code></pre>
<h3 id="声明支持设备">声明支持设备</h3>
<p>如果要声明我们的应用仅适用于支持 BLE 的设备，需要清单文件中做如下声明，如果我们希望我们的应用程序在不支持 BLE 的设备上也可以运行的时候，只需要将 true 修改成 false</p>
<pre><code>&lt;uses-feature android:name = &quot;android.hardware.bluetooth_le&quot; android:required = true /&gt;
</code></pre>
<p>在代码中判断是否支持BLE</p>
<pre><code>if(!getPackageManager().hasSystemFeature(PackgeManger.FEATURE_BLUETOOTH_LE)){
    // 不支持 BLE 设备
}
</code></pre>
<h2 id="蓝牙使用">蓝牙使用</h2>
<h3 id="设置蓝牙">设置蓝牙</h3>
<ul>
<li>获取蓝牙适配器</li>
</ul>
<pre><code> BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
    if(mBluetoothAdapter == null){
        // 说明此设备不支持蓝牙操作
    }
</code></pre>
<ul>
<li>启用蓝牙</li>
</ul>
<pre><code> // 是否开启蓝牙
 mBluetoothAdapter.isEnabled()
// 通过系统设置发出启用蓝牙
Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
startActivityForResult(enableBtIntent,REQUEST_ENBLE_BT);
// 直接打开蓝牙
mBluetoothAdapter.enable(); 
</code></pre>
<h3 id="查找设备">查找设备</h3>
<p>BluetoothAdapter通过设备发现或查询配对设备的列表来查找远程蓝牙设备。蓝牙设备仅在其当前已启用可检测时才会响应发现请求（返回设备名称，类和mac地址）。利用响应的数据可以与远程设备建立连接，首次建立连接后，将会自动向用户显示配对请求，完成配对后，则会将该设备信息（名称，mac地址）保存在本地（配对设备列表），下次则可以利用本地已知的mac地址发起连接而不需要执行设备发现。
<img src="https://bingocode.github.io//post-images/1562918316320.png" alt=""></p>
<ul>
<li>发现设备：发现BLE设备和发现普通蓝牙设备方法不一样，并且，只能单独发现普通蓝牙设备或BLE设备，没办法同时执行。发现是一个异步过程，但对于蓝牙适配器来来说会消耗大量资源，所以要确保停止发现后再去连接。</li>
<li>可检测性：Android设备默认是处于不可检测状态的，可以发送Intent使系统设置发出可检测模式请求，之后默认设备会变为可检测状态并持续120s，也可以自定义持续时间，最大为3600s。之后将会显示一个用户允许的对话框。若设备未开启蓝牙，启用设备可检测性时会自动启用蓝牙</li>
</ul>
<pre><code> Intent discoverableIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
 discoverableIntent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION,300);
 startActivityForResult(discoverableIntent);
</code></pre>
<ul>
<li>配对：意味着两台设备知晓彼此的存在，具有可用于身份验证的共享链路密钥，并且能够与彼此建立加密连接。在执行设备发现之前，有必要先查询已配对设备。</li>
<li>连接：意味着设备当前共享一个 RFCOMM 通道，并且能够向彼此传输数据</li>
</ul>
<h3 id="连接设备">连接设备</h3>
<p>两台设备必须实现服务端/客户端机制才能创建连接（一台必须开放服务器套接字，一台必须发起连接）。当服务器和客户端在同一 RFCOMM 通道上分别拥有已连接的 BluetoothSocket 时，二者将被视为彼此连接。在这种情况下每台设备都能获得输入和输出流式传输，并且可以开始传输数据。在连接之前若两个设备未配对，则会自动发出配对请求。</p>
<ul>
<li>服务器设备必须保持开放一个<strong>BluetoothServerSocket</strong>，监听传入的连接请求，在接受请求后从<strong>BluetoothServerSocket</strong>提供一个已经连接的<strong>BluetoothSocket</strong>，然后就可以close这个监听，并释放<strong>BluetoothServerSocket</strong>的所有资源，但不会关闭已经连接的<strong>BluetoothSocket</strong>，与TCP/IP不同的是RFCOMM 一次只允许每个通道有一个已经连接的客户端</li>
<li>客户端设备通过connect发起连接，系统将会在远程设备上执行 SDP 查找，来匹配 UUID。如果查找成功了并且远程设备接受了该连接，它将共享 RFCOMM 通道在连接期间使用。这个时候 connect() 就会返回。这个方法也是阻塞的，如果失败或者超时（12秒之后），将引发异常。调用 connect 的时候要确保客户端没有执行发现操作。如果执行了会大幅度降低连接的速度，增加失败的可能性，因此在连接之前，应该尽量都要调用一次cancelDiscovery（无论是否在扫描）</li>
<li>建立连接后，两个设备都有一个<strong>BluetoothSocket</strong>，并通过该Socket进行流式传输数据4</li>
<li>与BLE设备连接，就是连接到该设备的GATT服务，并得到一个BluetoothGatt对象，通过该对象和BLE设备交互，在支持的位置读取和写入属性。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何优雅地踩点赶公交]]></title>
        <id>https://bingocode.github.io//post/ru-he-you-ya-di-cai-dian-gan-gong-jiao</id>
        <link href="https://bingocode.github.io//post/ru-he-you-ya-di-cai-dian-gan-gong-jiao">
        </link>
        <updated>2019-07-10T07:44:43.000Z</updated>
        <content type="html"><![CDATA[<p>赶公交</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《长安十二时辰》——数据挖掘在唐朝的应用与扩展]]></title>
        <id>https://bingocode.github.io//post/lesslesschang-an-shi-er-shi-chen-greatergreater-shu-ju-wa-jue-zai-tang-zhao-de-ying-yong-yu-kuo-zhan</id>
        <link href="https://bingocode.github.io//post/lesslesschang-an-shi-er-shi-chen-greatergreater-shu-ju-wa-jue-zai-tang-zhao-de-ying-yong-yu-kuo-zhan">
        </link>
        <updated>2019-07-08T11:21:22.000Z</updated>
        <content type="html"><![CDATA[<p>如题</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android进阶]]></title>
        <id>https://bingocode.github.io//post/android-jin-jie</id>
        <link href="https://bingocode.github.io//post/android-jin-jie">
        </link>
        <updated>2019-07-08T11:19:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="android">Android</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[程序员修炼之道]]></title>
        <id>https://bingocode.github.io//post/cheng-xu-yuan-xiu-lian-zhi-dao</id>
        <link href="https://bingocode.github.io//post/cheng-xu-yuan-xiu-lian-zhi-dao">
        </link>
        <updated>2019-07-08T08:09:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="注重实效的哲学">注重实效的哲学</h2>
<ul>
<li>最大的弱点在于害怕暴露弱点，负责是指遇到问题会提供各种选择，而不是找各种借口，不要害怕提出要求，也不要害怕承认你需要帮助。</li>
<li>软件的熵（一个系统中无序的总量）需要通过不断优化劣质代码来降低，防止软件腐烂，就必须与熵战斗到底</li>
<li>石头汤：开发协作由于每个人时间安排不一致，但是为了避免项目的拖延，可以先完成自己的那部分功能，然后给大家看，等着他们开始增加你想要的功能，因为让人们参与正在发生的成功更容易，让他们瞥见未来，就能让他们聚集在你周围。并且必须留心大图景，持续观察周围发生的改变，而不只是你自己在做的事情。</li>
<li>要注意物极必反，你所要完成的项目的范围和质量应该作为项目需求的一部分规定下来，让质量成为需求问题。我们要学会在不完美的世界上合理地编写代码</li>
<li>知识上的投资总能够得到最好的回报，要学会管理知识资产
1.定期投资作为习惯
2.多元化投资是长期成功的关键
3.聪明的投资者会权衡风险和回报
4.设法低买高卖以获得最大回报：在新兴技术流行前学习它可能就和找到被低估的股票一样
5.应该周期性地重新评估和平衡资产</li>
<li>每年至少学习一种新语言，每个月读一本书（技术和非技术），打听公司以外的人都在做什么，试验不同的环境（系统，IDE，软件），跟上潮流，持续投入，设法将所学应用到项目中。</li>
<li>遇到问题先自己找答案，再去找出能找到答案的人，而不是搁置问题，与人交谈不仅帮你建立人际网络，还能促进旧的知识资产增长。</li>
<li>批判地思考所学，确保知识资产是准确无误的，才能够理解一些复杂的答案</li>
<li>寻找答案？
1.明确到底想问什么
2.组织问题，表达寻求帮助，而不是要求对方必须回答
3.坐回原位，耐性等待，每个人都很忙</li>
<li>交流：想说什么？了解听众（需要，能力，兴趣）？时机？风格？获取反馈？回复他人</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flutter混合开发]]></title>
        <id>https://bingocode.github.io//post/flutter-hun-he-kai-fa</id>
        <link href="https://bingocode.github.io//post/flutter-hun-he-kai-fa">
        </link>
        <updated>2019-07-08T04:21:50.000Z</updated>
        <content type="html"><![CDATA[<p>##配置</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://bingocode.github.io//post/about</id>
        <link href="https://bingocode.github.io//post/about">
        </link>
        <updated>2019-01-25T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="关于我">关于我</h2>
<p>你好，这是我的博客，很荣幸可以与阁下分享我的人生轨迹。本人目前从事Android开发。</p>
<h2 id="关于博客">关于博客</h2>
<p>采用静态博客写作客户端<a href="https://gridea.dev/">Gridle</a>编写，存放在<a href="https://github.com/bingocode/bingocode.github.io">Github Page</a></p>
<h2 id="联系方式">联系方式</h2>
<p>QQ: 2416940975<br>
e-mail: bingocoder@outlook.com</p>
]]></content>
    </entry>
</feed>